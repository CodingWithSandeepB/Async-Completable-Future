import dto.Employees;import java.util.concurrent.CompletableFuture;import java.util.concurrent.Executor;import java.util.concurrent.Executors;import java.util.stream.Collectors;public class EmployeeService {    public CompletableFuture<Void> getAllEmployeesPart2(){        Executor executor = Executors.newFixedThreadPool(20);        CompletableFuture<Void> employeesList = CompletableFuture.supplyAsync(() -> {            System.out.println("executed by Thread: " + Thread.currentThread().getName());            return EmployeeDAO.fetchEmployees();        }, executor).thenApplyAsync((employees -> {            System.out.println("Filter New Joinee using Thread: " + Thread.currentThread().getName());            return employees.stream()                    .filter(employees1 -> employees1.isNewJoiner()                            .equalsIgnoreCase("TRUE"))                    .collect(Collectors.toList());        }), executor).thenApplyAsync((employees -> {            System.out.println("Filter Pending Training by Thread: " + Thread.currentThread().getName());            return employees.stream()                    .filter(employees1 -> employees1.isLearningPending()                            .equalsIgnoreCase("TRUE"))                    .collect(Collectors.toList());        }), executor).thenApplyAsync((employees -> {            System.out.println("Map list of Emp emails by Thread: " + Thread.currentThread().getName());            return employees.stream().map(Employees::getEmail).collect(Collectors.toList());        }), executor).thenAcceptAsync((emails) -> {            System.out.println("send email  : " + Thread.currentThread().getName());            emails.stream().forEach(EmployeeService::getEmailList);        }, executor);        return employeesList;    }    private static void getEmailList(String emails){        System.out.println("Sending training reminder email notification to the Employee email: " + emails);    }}